---
title: Java IO流
entitle: Java-IO-Stream
tags: [Java,IO]
categories:
  - Java
  - IO
date: 2019-04-23 23:13:07
---
本文截取自Simon_night<https://blog.csdn.net/nightcurtis/article/details/51324105>。总结Java IO知识点。
<!--more-->
## Java I/O流的概念，分类，类图
### I/O流的概念
Java的IO是实现输入和输出的基础，可以方便的实现数据的输入和输出操作。在Java中把不同的输入/输出源抽象表述为“流(Stream)”。通过流的形式运行Java程序使用相同的方式来访问不同的输入/输出源。Stream是从起源(source)到接收的(Sink)的有序数据。
### I/O流的分类
#### 按流的流向划分
* 输入流：只能从中读取数据，而不能向其写入数据
* 输出流：只能向其写入数据，而不能从中读取数据

> 划分输入/输出流时是从程序运行所在的内存的角度来考虑的。java的输入流主要是`InputStream`和`Reader`作为基类，而输出流则是主要由`outputStream`和`Writer`作为基类。它们都是一些抽象基类，无法直接创建实例。

#### 按照操作单元划分
字节流和字符流的用法几乎完成全一样，区别在于字节流和字符流所操作的数据单元不同，字节流操作的单元是数据单元是8位的字节，字符流操作的是数据单元为16位的字符。
#### 按照流的角色划分
* 节点流(低级流)：可以从/向一个特定的IO设备（如磁盘，网络）读/写数据的流
* 处理流(高级流)：用于对一个已存在的流进行连接和封装，通过封装后的流来实现数据的读/写功能
当使用处理流进行输入/输出时，程序并不会直接连接到实际的数据源，没有和实际的输入和输出节点连接。使用处理流的一个明显的好处是，只要使用相同的处理流，程序就可以采用完全相同的输入/输出代码来访问不同的数据源，随着处理流所包装的节点流的变化，程序实际所访问的数据源也相应的发生变化。
### 流的原理浅析和常用的流的分类表
#### 流的原理浅析
java IO流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java Io流的40多个类都是从如下4个抽象类基类中派生出来的。
* `InputStream/Reader`: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
* `OutputStream/Writer`: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

处理流的功能：
* 性能的提高：主要以增加缓冲的方式来提供输入和输出的效率
* 操作的便捷：处理流可能提供了一系列便捷的方法来一次输入和输出大批量的内容

## 常用的IO流的用法
### I/O体系的基类(InputStream/Reader，OutputStream/Writer)
`InputStream`和`Reader`是所有输入流的抽象基类，本身并不能创建实例来执行输入，但它们将成为所有输入流的模板，所以它们的方法是所有输入流都可使用的方法。

### 在`InputStream`里面包含如下3个方法

* `int read();` 从输入流中读取单个字节，返回所读取的字节数据（字节数据可直接转换为int类型）
* `int read(byte[] b);`从输入流中最多读取`b.length`个字节的数据，并将其存储在字节数组b中，返回实际读取的字节数
* `int read(byte[] b,int off,int len);` 从输入流中最多读取len个字节的数据，并将其存储在数组b中，放入数组b中时，并不是从数组起点开始，而是从off位置开始，返回实际读取的字节数

### 在`Reader`中包含如下3个方法。
* `int read();` 从输入流中读取单个字符，返回所读取的字符数据（字节数据可直接转换为`int`类型）
* `int read(char[] b);`从输入流中最多读取`b.length`个字符的数据，并将其存储在字节数组b中，返回实际读取的字符数
* `int read(char[] b,int off,int len);` 从输入流中最多读取`len`个字符的数据，并将其存储在数组`b`中，放入数组`b`中时，并不是从数组起点开始，而是从`off`位置开始，返回实际读取的字符数

`InputStream`和`Reader`提供的一些移动指针的方法：
* `void mark(int readAheadLimit);` 在记录指针当前位置记录一个标记（mark）
* `boolean markSupported(); `判断此输入流是否支持mark()操作，即是否支持记录标记
* `void reset(); `将此流的记录指针重新定位到上一次记录标记（mark）的位置
* `long skip(long n); `记录指针向前移动n个字节/字符

#### OutputStream和Writer： 
`OutputStream`和`Writer`的用法也非常相似，两个流都提供了如下三个方法：

* `void write(int c);` 将指定的字节/字符输出到输出流中，其中`c`即可以代表字节，也可以代表字符
* `void write(byte[]/char[] buf);` 将字节数组/字符数组中的数据输出到指定输出流中
* `void write(byte[]/char[] buf, int off,int len );` 将字节数组/字符数组中从`off`位置开始，长度为`len`的字节/字符输出到输出流中
因为字符流直接以字符作为操作单位，所以`Writer`可以用字符串来代替字符数组，即以String对象作为参数。`Writer`里面还包含如下两个方法。

* `void write(String str);` 将str字符串里包含的字符输出到指定输出流中
* `void write (String str, int off, int len);` 将`str`字符串里面从`off`位置开始，长度为len的字符输出到指定输出流中

###  IO体系的基类文件流的使用(`FileInputStream/FileReader` ，`FileOutputStream/FileWriter`)
`InputStream`和`Reader`都是抽象类，本身不能创建实例，但它们分别有一个用于读取文件的输入流：`FileInputStream`和`FileReader`，它们都是节点流——会直接和指定文件关联。`FileInputStream`和`FileReader`进行文件的读写并没有什么区别，只是操作单元不同
> 使用java的io流执行输出时，不要忘记关闭输出流，关闭输出流除了可以保证流的物理资源被回收之外，可能还可以将输出流缓冲区中的数据flush到物理节点中里（因为在执行`close（）`方法之前，自动执行输出流的`flush（）`方法）。java很多输出流默认都提供了缓存功能，其实我们没有必要刻意去记忆哪些流有缓存功能，哪些流没有，只有正常关闭所有的输出流即可保证程序正常。

使用字节缓存流读取和写入数据的方式和文件流(`FileInputStream`,`FileOutputStream`)并没有什么不同，只是把处理流套接到文件流上进行读写。
> 当我们使用处理流套接到节点流上的使用的时候，只需要关闭最上层的处理就可以了。java会自动帮我们关闭下层的节点流。

### 转换流的使用(`InputStreamReader/OutputStreamWriter`)
`InputStreamReader`将`System.in`包装成`BufferedReader`,利用`BufferedReader`的`readLine()`方法可以一次读取一行内容。`BufferedReader`流具有缓存功能，它可以一次读取一行文本——以换行符为标志，如果它没有读到换行符，则程序堵塞。等到读到换行符为止。运行上面程序可以发现这个特征，当我们在控制台执行输入时，只有按下回车键，程序才会打印出刚刚输入的内容。

### 对象流的使用(`ObjectInputStream/ObjectOutputStream`)
> 读取顺序和写入顺序一定要一致，不然会读取出错。在对象属性前面加`transient`关键字，则该对象的属性不会被序列化。

## 何为NIO，和传统IO的区别
我们使用`InputStream`从输入流中读取数据时，如果没有读取到有效的数据，程序将在此处阻塞该线程的执行。其实传统的输入里和输出流都是阻塞式的进行输入和输出。 不仅如此，传统的输入流、输出流都是通过字节的移动来处理的(即使我们不直接处理字节流，但底层实现还是依赖于字节处理)，也就是说，面向流的输入和输出一次只能处理一个字节，因此面向流的输入和输出系统效率通常不高.
从JDk1.4开始，java提供了一系列改进的输入和输出处理的新功能，这些功能被统称为新IO(NIO)。新增了许多用于处理输入和输出的类，这些类都被放在`java.nio`包及其子包下，并且对原io的很多类都以NIO为基础进行了改写。新增了满足NIO的功能。 
NIO采用了内存映射对象的方式来处理输入和输出，NIO将文件或者文件的一块区域映射到内存中，这样就可以像访问内存一样来访问文件了。通过这种方式来进行输入/输出比传统的输入和输出要快的多。


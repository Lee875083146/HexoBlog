---
title: 并发专题——深入解读volatile
tags: [并发,volatile]
categories:
- Java
- 并发
date: 2020-01-03 22:47:44
entitle: Java-Concurrency-Volatile
---

volatile关键字作为Java并发的基础对理解整个Java并发体系十分重要。本文将剖析volatile的作用及背后的实现原理。

<!--more-->

## 初识volatile

volatile作为Java的关键字之一，通过同步共享变量和禁止重排序，在JVM层面保证了共享变量的可见性和有序性。

## volatile与JMM Java内存模型

在了解volatile的工作原理之前，我们需要知道JMM——Java内存模型，了解Java中数据是如何在线程与主存分布交互的，JMM定义了程序中各个变量的访问规则。

与处理器类似，Java中每一个线程都有独自的工作内存还有与所有线程共享的主内存，共享变量在多个线程的工作内存都有缓存，如果不对其进行同步控制，线程将无法感知其他线程对共享变量的修改。

Java通过几种原子操作完成工作内存和主内存的交互：
* lock：作用于主内存，把变量标识为线程独占状态。
* unlock：作用于主内存，解除独占状态。
* read：作用主内存，把一个变量的值从主内存传输到线程的工作内存。
* load：作用于工作内存，把read操作传过来的变量值放入工作内存的变量副本中。
* use：作用工作内存，把工作内存当中的一个变量值传给执行引擎。
* assign：作用工作内存，把一个从执行引擎接收到的值赋值给工作内存的变量。
* store：作用于工作内存的变量，把工作内存的一个变量的值传送到主内存中。
* write：作用于主内存的变量，把store操作传来的变量的值放入主内存的变量中。

## 重排序




## 可见性

首先需要了解JMM java内存模型。


可见性的定义即为当一个线程修改了线程共享变量的值，在其他线程使用之前，能够得到最新的值。

volatile变量在线程缓存中更新后，会做两件事，第一是将新的值写会到主存中；第二是会通知其他线程，使其缓存失效，再取值时会从主存中获取最新值。

volatile是JVM层面的要求。因为并不是所有的硬件架构都提供了相同的一致性保证；可见性并不仅存在于CPU缓存，还存在于JVM的内存模型中。

处理器层面的缓存一致性由缓存一致性协议保证，最经典的是MESI协议。MESI协议规定了缓存的四种状态：Modified、Exclusive、Shared、Invalid。

* Modified：数据有效，只存在于本Cache，且已修改与主存不一致
* Exclusive：数据有效，存在于本Cache，且与主存一致
* Shared：数据有效，存在于多个Cache且与主存一致
* Invalid：数据无效

处理器会监听缓存的操作，使其在四个状态之间流转，不同的状态，会进行不同的数据同步操作。保证了数据在不同缓存的可见性。

## 有序性

顺序一致性

编译器和处理器会进行重排序，以提高执行的效率。
重排序体现在三部分：
* 编译器会优化代码的顺序
* 处理器会对指令进行重排序，会导致可见性问题
* 由于读写缓存的存在会导致乱序。本质上是可见性问题，实际上并没有重排序，看起来发生了重排序

volatile通过优化屏障避免编译器重排序操作，保证编译程序时在优化屏障之前的指令不会在优化屏障之后执行。

内存屏障解决了硬件层面的可见性和重排序问题。

屏障类型|指令示例|说明
-|-|-
LoadLoad Barriers|Load1;LoadLoad;Load2|该屏障确保Load1数据的装载先于Load2及其后所有装载指令的的操作
StoreStore Barriers|Store1;StoreStore;Store2|该屏障确保Store1立刻刷新数据到内存(使其对其他处理器可见)的操作先于Store2及其后所有存储指令的操作
LoadStore Barriers|Load1;LoadStore;Store2|确保Load1的数据装载先于Store2及其后所有的存储指令刷新数据到内存的操作
StoreLoad Barriers|Store1;StoreLoad;Load2|该屏障确保Store1立刻刷新数据到内存的操作先于Load2及其后所有装载装载指令的操作。它会使该屏障之前的所有内存访问指令(存储指令和访问指令)完成之后,才执行该屏障之后的内存访问指令

内存屏障 (Memory Barrier)分为写屏障（Store Barrier）、读屏障（Load Barrier）和全屏障（Full Barrier），其作用有两个：

1. 防止指令之间的重排序
2. 保证数据的可见性

## 在DCL中的作用分析

##


## 总结

可见性分为两种情况：
* CPU缓存——由MESI协议保证
* JMM读写缓存——由内存屏障保证

有序性是由重排序导致：
* 编译器——优化屏障
* 指令——内存屏障
* 读写缓存引发重排序导致可见性——内存屏障

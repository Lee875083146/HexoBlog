<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Spring中Bean的注入方式"><meta name="keywords" content="DI,Spring,依赖注入"><meta name="author" content="nopainanymore"><meta name="copyright" content="nopainanymore"><title>Spring中Bean的注入方式 | No Pain AnyMore</title><link rel="shortcut icon" href="https://nopainanymore.oss-cn-hangzhou.aliyuncs.com/favicon.jpg?x-oss-process=style/sw-white"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?https://hm.baidu.com/hm.js?ca6ee8d386d608e489e2f483d8553676";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"TBN51XHQ7I","apiKey":"ad36c28a1992fcfba299a447cf3558b9","indexName":"hexo","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#注入方式"><span class="toc-number">1.</span> <span class="toc-text"> 注入方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stackoverflow上的讨论"><span class="toc-number">2.</span> <span class="toc-text"> StackOverflow上的讨论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#问题"><span class="toc-number">2.1.</span> <span class="toc-text"> 问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#回答及讨论"><span class="toc-number">2.2.</span> <span class="toc-text"> 回答及讨论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#回答一"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 回答一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#回答二"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 回答二</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#oliver-gierke博文"><span class="toc-number">3.</span> <span class="toc-text"> Oliver Gierke博文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#npe"><span class="toc-number">3.1.</span> <span class="toc-text"> NPE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可测试性"><span class="toc-number">3.2.</span> <span class="toc-text"> 可测试性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#样板打破者lombok"><span class="toc-number">3.3.</span> <span class="toc-text"> 样板打破者——Lombok</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对比"><span class="toc-number">3.4.</span> <span class="toc-text"> 对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text"> 总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">5.</span> <span class="toc-text"> 参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://ww1.sinaimg.cn/large/005yN1Nlgy1g0lee3rjxbj311s0scgpu.jpg"></div><div class="author-info__name text-center">nopainanymore</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/Lee875083146">GitHub</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">80</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">100</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">86</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">No Pain AnyMore</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/learningPlan">LearningPlan</a><a class="site-page" href="/about">About</a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">Spring中Bean的注入方式</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-09</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Spring/"> Spring</a></div><div class="article-container" id="post-content"><p>本文探讨Spring团队为什么推荐构造方法注入。</p>
<a id="more"></a>
<p>之前一直都是用构造方法注入，现在的项目中很多都是成员变量注入，Spring的依赖注入有三种形式，当使用成员变量注入时，IDEA将会有以下提示，为什么Spring团队推荐使用构造方法注入呢？本文将探讨一下这个问题。</p>
<p><a href="https://nopainanymore.oss-cn-hangzhou.aliyuncs.com/Spring/%E6%88%AA%E5%B1%8F2020-01-2011.01.24.png?x-oss-process=style/sw-white" target="_blank" rel="noopener">!Spring-Team—Recommend</a></p>
<h2 id="注入方式"><a class="markdownIt-Anchor" href="#注入方式"></a> 注入方式</h2>
<ul>
<li>构造方法注入</li>
<li>成员变量注入</li>
<li>setter注入</li>
</ul>
<p>现在流行的一般是构造方法注入和成员变量两种，那么为什么Spring团队推荐使用构造方法注入呢？在StackOverFlow以及<a href="https://spring.io/team/ogierke" target="_blank" rel="noopener">Oliver Gierke</a>的一篇<a href="http://olivergierke.de/2013/11/why-field-injection-is-evil/" target="_blank" rel="noopener">博客</a>上找到了相关的讨论和分析。</p>
<blockquote>
<p>Oliver Gierke is the lead of the Spring Data project at Pivotal, formerly known as SpringSource, and member of the JPA 2.1 expert group.</p>
</blockquote>
<h2 id="stackoverflow上的讨论"><a class="markdownIt-Anchor" href="#stackoverflow上的讨论"></a> StackOverflow上的讨论</h2>
<p>StackOverFlow的问题见<a href="https://stackoverflow.com/questions/40620000/spring-autowire-on-properties-vs-constructor" target="_blank" rel="noopener">https://stackoverflow.com/questions/40620000/spring-autowire-on-properties-vs-constructor</a>，我选择了我认为解答比较好的两个回答做了翻译。</p>
<h3 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h3>
<p>Spring中Service的依赖有以下两种写法，我知道两种方式都可以工作，但是使用第二种有什么优势呢？它在写类和单测时需要写更多的代码。我是否有遗漏的地方，这种方式是一种更好的依赖注入方式吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeService</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Autowired</span> <span class="keyword">private</span> SomeOtherService someOtherService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I have now run across code that uses another convention to achieve the same goal</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SomeOtherService someOtherService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SomeService</span><span class="params">(SomeOtherService someOtherService)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.someOtherService = someOtherService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="回答及讨论"><a class="markdownIt-Anchor" href="#回答及讨论"></a> 回答及讨论</h3>
<h4 id="回答一"><a class="markdownIt-Anchor" href="#回答一"></a> 回答一</h4>
<p>是的，比起成员变量注入确实更加推荐第二种方式（构造方法注入）。它有以下几个优点：</p>
<ul>
<li>使用构造方法注入时，依赖是十分明确的。当在测试或者在其他任意场景实例化一个对象的时候，是不会忘记任何依赖的。</li>
<li>依赖被<code>final</code>修饰，这对代码的健壮性和线程安全起到帮助作用</li>
<li>不需要使用反射来设置依赖。使用<code>@InjectMocks</code>时仍然起作用但是不是必要的。你可以创建自己mock的对象，并通过简单的调用构造方法将他们注入。</li>
</ul>
<p>—— JB Nizet</p>
<p>讨论:</p>
<p>让我们深入挖掘，假设你有一些其他的配置，例如<code>@Value(&quot;some.prop&quot;) private String property</code>，你也会将它一起设置到构造方法里面吗？这最终好像只会让你得到一个拥有非常长的参数的构造方法。它本身不坏只不过是有更多的代码。<br>
—— GSUgambit</p>
<p>是的，你应该将这些配置也放到构造方法中。当构造方法的参数过多是，常常是你应该将类分解成更多小的类的标志，让每个类拥有更少的自己的职责和依赖。<br>
—— JB Nizet</p>
<h4 id="回答二"><a class="markdownIt-Anchor" href="#回答二"></a> 回答二</h4>
<p>在方式一中，允许任意的类（无论是否在<code>Spring</code>容器中）都可以使用默认的构造方法去创建实例（<code>new SomeService()</code>），当你在你需要一个<code>SomeOtherService</code>作为<code>SomeService</code>的依赖时，这样做是不好的。</p>
<p>那么除了将代码添加到单元测试中，构造方法注入还有其他功能吗？这是进行依赖注入更好的方法吗？</p>
<p>方式二是首选的方法，因为在实际没有解决<code>SomeOtherService</code>依赖的时候，他不允许去创建一个<code>SomeService</code>。</p>
<p>—— developer</p>
<h2 id="oliver-gierke博文"><a class="markdownIt-Anchor" href="#oliver-gierke博文"></a> Oliver Gierke博文</h2>
<p>原文链接：<a href="http://olivergierke.de/2013/11/why-field-injection-is-evil/" target="_blank" rel="noopener">http://olivergierke.de/2013/11/why-field-injection-is-evil/</a></p>
<p>讨论这个问题的上下文是：我们希望去实现一个<code>Component</code>持有一个<code>Collaborator</code>。众所周知，依赖注入是链接两个<code>Component</code>最直接简单的方法，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span> MyCollaborator collaborator;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myBusinessMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    collaborator.doSomething();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="npe"><a class="markdownIt-Anchor" href="#npe"></a> NPE</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyComponent component = <span class="keyword">new</span> MyComponent();</span><br><span class="line">component.myBusinessMethod(); <span class="comment">// -&gt; NullPointerException</span></span><br></pre></td></tr></table></figure>
<p>这个问题的核心在于，你的代码是否允许客户端去创建一个处于无效状态的实例。类存在的目的就是客户端能够强制依赖一个不变量。这也是你代码中使用<code>EmailAddress</code>类而不是简单使用一个<code>String</code>去表示email address的原因之一。由于在构造方法能保证强制约束类对象的合法性，所以就能保证客户端获取的<code>EmailAddress</code>实例是有效的，而<code>String</code>则无法保证，它可以任何东西，无论是否有效。</p>
<p>所以你可以猜想出这个将指向构造方法注入，让我们用体现我刚刚概述特征的方式去重构上述的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MyCollaborator collaborator;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyComponent</span><span class="params">(MyCollaborator collaborator)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(collaborator, <span class="string">"MyCollaborator must not be null!"</span>);</span><br><span class="line">    <span class="keyword">this</span>.collaborator = collaborator;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myBusinessMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    collaborator.doSomething();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以概括出来：</p>
<ol>
<li>只能通过提供一个<code>MyCollaborator</code>来创建一个<code>MyComponent</code>的实例。强制客户端提供一个必须存在的依赖，确保所有的对象通过构造方法创建之后是有效的。</li>
<li>将依赖通过构造方法的方式声明成为强制性的。成员变量注入只不过是想把丑陋的事物做成美好事物而做的无用功，只看公共接口你依然不知道依赖关系。特别是如果你在项目间分享代码，那么成员变量注入将会使方法变成重复循环“执行-等待NPE发生-声明缺失的<code>Bean</code>”的方法。</li>
<li><code>final</code>类型的字段也增加了应用程序组件的稳定性。可以通过是否被final修饰可以清楚的分辨哪些是强制依赖哪些是可选依赖。</li>
</ol>
<p>还有一个经常遇到的争论是构造方法中的变量太多了。一个类依赖的增长将导致不好的结果，这标志着你应该思考是否应该将一个<code>Component</code>分解成多个。</p>
<h3 id="可测试性"><a class="markdownIt-Anchor" href="#可测试性"></a> 可测试性</h3>
<p>回到对构造方法注入方式代码量对讨论上。假设我们使用成员变量对注入方式，我们的代码量确实会少一些，但是我猜你也在为你的类写测试代码，所以，在测试中你是如何将一个依赖注入到你的<code>Component</code>中呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyCollaborator collaborator = … <span class="comment">// mock dependency</span></span><br><span class="line">MyComponent component = <span class="keyword">new</span> MyComponent();</span><br><span class="line"><span class="comment">// Inject dependency by some reflection magic</span></span><br><span class="line">component.myBusinessMethod();</span><br></pre></td></tr></table></figure>
<p>反射是一个解决办法，但是无论你是用一些帮助工具或者类似的方法去是你写起来舒服，这种解决方式仍然是一个比较乱的方法，不是吗？特别是当替代的方法比较简单的时候：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyCollaborator collaborator = … <span class="comment">// mock dependency</span></span><br><span class="line">MyComponent component = <span class="keyword">new</span> MyComponent(collaborator);</span><br><span class="line">component.myBusinessMethod();</span><br></pre></td></tr></table></figure>
<p>当你为被测试的类增加依赖、重构代码或者没有设置依赖的各种情况下，通过构造方法调用的时候都可以使代码完成。</p>
<h3 id="样板打破者lombok"><a class="markdownIt-Anchor" href="#样板打破者lombok"></a> 样板打破者——Lombok</h3>
<p>诚然，我在开始使用构造方法注入的时候，被要写的代码量所打击。这显然是Java的语言缺陷。不幸的是，很多面向对象的好的实践，比如ValueObjects，委派大于继承，构造方法注入等在Scala这样的语言中是很容易实现的。</p>
<p>然而，ProjectLombok在减少很多样板代码方面起了很大的作用。在Lombok中有很多有用的的特性，但是我想集中在与本次讨论相关的地方。使用Lombok时，我的Component的构造方法注入代码像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span>(onConstructor = @__(<span class="meta">@Inject</span>))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@NonNull</span> MyCollaborator collaborator;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myBusinessMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    collaborator.doSomething();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@RequiredArgsConstructor 注解在编译阶段将生成一个包含所有final字段的构造方法，额外的@NonNull注解将会检查参数是否为null。这个奇怪的 onConstructor是Lombok让你在生成的构造方法上添加注解的方式，所以通过额外的注解你可以有效的获取你想要的API。</p>
<h3 id="对比"><a class="markdownIt-Anchor" href="#对比"></a> 对比</h3>
<table>
<thead>
<tr>
<th>注入方式</th>
<th>代码量</th>
<th>安全性</th>
<th>测试难度</th>
</tr>
</thead>
<tbody>
<tr>
<td>成员变量注入</td>
<td>少</td>
<td>不安全</td>
<td>测试较复杂</td>
</tr>
<tr>
<td>构造方法注入</td>
<td>多</td>
<td>安全</td>
<td>容易测试</td>
</tr>
</tbody>
</table>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<blockquote>
<p>The Spring team generally advocates constructor injection, as it lets you implement application components as immutable objects and ensures that required dependencies are not null. Furthemore, constructor-injected components are always returned to the client(calling) code in a fully initialized state. As a side note, a large number of constructor arguments is a bad code semll, implying that the class likely has too many responsibilities and should be refactored to better address proper separation of concerns.</p>
</blockquote>
<blockquote>
<p>Setter injection should primarily only be used for optional dependencies that can be assigned resonable default values within the class. Otherwise, non-null checks must be performed everywhere the code uses the dependency. One bennefit of setter injection is that setter methods make objects of that class amenable to reconfiguration or re-injection later. Management through JMX MBeans is therefore a compelling use case for setter injection.</p>
</blockquote>
<p>以上是Spring团队对构造方法注入和setter方法注入的总结。</p>
<p>Spring团队之所以推荐使用构造方法注入主要是以下几点原因：</p>
<ul>
<li>通过构造方法，声明依赖，避免了在测试或者其他环境下依赖的缺失</li>
<li>避免了因依赖确实而导致的NPE</li>
<li>增强了程序的稳定性，可测试性</li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<p><a href="https://stackoverflow.com/questions/40620000/spring-autowire-on-properties-vs-constructor" target="_blank" rel="noopener">https://stackoverflow.com/questions/40620000/spring-autowire-on-properties-vs-constructor</a><br>
<a href="http://olivergierke.de/2013/11/why-field-injection-is-evil/" target="_blank" rel="noopener">http://olivergierke.de/2013/11/why-field-injection-is-evil/</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">nopainanymore</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://nopainanymore.me/Spring-Injection/">http://nopainanymore.me/Spring-Injection/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DI/">DI</a><a class="post-meta__tags" href="/tags/Spring/">Spring</a><a class="post-meta__tags" href="/tags/依赖注入/">依赖注入</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://nopainanymore.oss-cn-hangzhou.aliyuncs.com/wechat.jpg?x-oss-process=style/sw-white"><div class="post-qr-code__desc">wechat</div></div></div><div class="social-share" data-disabled="diandian,tencent,qzone,google"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/Object-Oriented/"><i class="fa fa-chevron-left">  </i><span>面向对象</span></a></div><div class="next-post pull-right"><a href="/Java-Concurrency-Volatile/"><span>并发专题——深入解读volatile</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'b5808ee24dc05257f520',
  clientSecret: '4b96b67ee846f12c0c590dfd71312ba19edea774',
  repo: 'lee875083146.github.io',
  owner: 'Lee875083146',
  admin: 'Lee875083146',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By nopainanymore</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>